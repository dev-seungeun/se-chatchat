{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useRef } from \"react\";\nimport throttle from \"./useThrottle\";\n\nconst useNotification = (title, options) => {\n  _s();\n\n  const notificationRef = useRef();\n  const timerRef = useRef();\n\n  if (!(\"Notification\" in window)) {\n    return;\n  } // const fireNotif = () => {\n\n\n  if (Notification.permission !== \"granted\") {\n    try {\n      Notification.requestPermission().then(permission => {\n        if (permission !== 'granted') return; //else new Notification(title, options);\n      });\n    } catch (error) {\n      if (error instanceof TypeError) {\n        Notification.requestPermission(permission => {\n          if (permission !== 'granted') return; //else new Notification(title, options);\n        });\n      } else {\n        console.error(error);\n      }\n    }\n  } // else {\n  //   new Notification(title, options);\n  // }\n  // };\n\n\n  const setNotificationClickEvent = () => {\n    notificationRef.current.onclick = event => {\n      event.preventDefault();\n      window.focus();\n      notificationRef.current.close();\n    };\n  }; // Notification을 위한 타이머를 설정하는 함수!\n  // const setNotificationTimer = (timeout) => {\n  //   // clearTimeout을 하기 위해 timerRef에 저장해준다.\n  //   timerRef.current = setTimeout(() => {\n  //     // timeout에 넣어준 시간만큼 흐르면, 콜백이 실행되면서 timerRef.current에 null이 담기게 된다.\n  //     timerRef.current = null;\n  //\n  //     // 시간이 다 흘렀으면 푸시 알림이 꺼지도록 해준다.\n  //     notificationRef.current.close();\n  //     // 그리고 역할을 다한 notificationRef를 null로 초기화해준다.\n  //     notificationRef.current = null;\n  //   }, timeout);\n  // };\n\n\n  const setNotificationTimer = timeout => {\n    throttle(() => {\n      notificationRef.current.close();\n      notificationRef.current = null;\n    }, timeout);\n  }; // 어떤 알림을 보낼 것인지, 몇 초마다 알림을 보낼 것인지에 대한 함수\n\n\n  const fireNotificationWithTimeout = function (title, timeout) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // 만약 유저가 푸시 알림을 꺼놓았다면 함수가 실행되지 않게 미리 return을 해준다.\n    // 그런데 가드를 세워놨음에도 불구하고, Safari에서 실행되지 않는 문제점이 있었다. 이 문제는 해결중이다 ㅜㅜ!\n    if (Notification.permission !== 'granted') return; // Notification API는 두 번째 인자로 option 값을 받는데, 뱃지 이미지와 아이콘 등을 설정해 줄 수 있다.\n    // 초기 badge, icon을 설정해주었다.\n\n    const newOption = {\n      badge: 'https://babble.gg/img/logos/babble-speech-bubble.png',\n      icon: 'https://babble.gg/img/logos/babble-speech-bubble.png',\n      ...options\n    }; // 만약 notificationRef가 아직 초기화되지 않았다면, 타이머가 아직 동작하고 있는거니까 notificationRef가 없을 때에만 새로운 알림을 만든다.\n\n    if (!notificationRef.current) {\n      // 여기 들어왔다는건 타이머가 실행되지 않고 있다는 것이니까, 타이머를 만들어준다.\n      setNotificationTimer(timeout); // 푸시 알림에서 보여줄 title과 위에서 우리가 만든 custom option을 넣어준다.\n      // 이 Notification 함수는 할당해도 바로 실행되기 때문에 첫 이벤트는 무조건 실행되고, 그 이후부터 타이머가 작동한다.\n\n      notificationRef.current = new Notification(title, newOption); // // Notification의 Click Event를 새로 붙여준다.\n\n      setNotificationClickEvent();\n    }\n  };\n\n  return {\n    fireNotificationWithTimeout\n  };\n};\n\n_s(useNotification, \"0GdVkyA7iuhDxySPAUkUhdLPFf4=\");\n\nexport default useNotification;","map":{"version":3,"sources":["C:/workspaces/atom_workspace/sesh-chatchat/src/helpers/useNotification.js"],"names":["React","useRef","throttle","useNotification","title","options","notificationRef","timerRef","window","Notification","permission","requestPermission","then","error","TypeError","console","setNotificationClickEvent","current","onclick","event","preventDefault","focus","close","setNotificationTimer","timeout","fireNotificationWithTimeout","newOption","badge","icon"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,MAAhB,QAA8B,OAA9B;AACA,OAAOC,QAAP,MAAqB,eAArB;;AAEA,MAAMC,eAAe,GAAG,CAACC,KAAD,EAAQC,OAAR,KAAoB;AAAA;;AAE1C,QAAMC,eAAe,GAAGL,MAAM,EAA9B;AACA,QAAMM,QAAQ,GAAGN,MAAM,EAAvB;;AAEA,MAAI,EAAE,kBAAkBO,MAApB,CAAJ,EAAiC;AAC/B;AACD,GAPyC,CAQ5C;;;AACE,MAAIC,YAAY,CAACC,UAAb,KAA4B,SAAhC,EAA2C;AACzC,QAAI;AACFD,MAAAA,YAAY,CAACE,iBAAb,GAAiCC,IAAjC,CAAuCF,UAAD,IAAgB;AACpD,YAAIA,UAAU,KAAK,SAAnB,EAA8B,OADsB,CAEpD;AACD,OAHD;AAID,KALD,CAKE,OAAOG,KAAP,EAAc;AACd,UAAIA,KAAK,YAAYC,SAArB,EAAgC;AAC9BL,QAAAA,YAAY,CAACE,iBAAb,CAAgCD,UAAD,IAAgB;AAC7C,cAAIA,UAAU,KAAK,SAAnB,EAA8B,OADe,CAE7C;AACD,SAHD;AAID,OALD,MAKO;AACLK,QAAAA,OAAO,CAACF,KAAR,CAAcA,KAAd;AACD;AACF;AACF,GAzByC,CA0B1C;AACA;AACA;AACF;;;AAEE,QAAMG,yBAAyB,GAAG,MAAM;AACtCV,IAAAA,eAAe,CAACW,OAAhB,CAAwBC,OAAxB,GAAmCC,KAAD,IAAW;AAC3CA,MAAAA,KAAK,CAACC,cAAN;AACAZ,MAAAA,MAAM,CAACa,KAAP;AACAf,MAAAA,eAAe,CAACW,OAAhB,CAAwBK,KAAxB;AACD,KAJD;AAKD,GAND,CA/B0C,CAuC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAMC,oBAAoB,GAAIC,OAAD,IAAa;AACvCtB,IAAAA,QAAQ,CAAC,MAAM;AACbI,MAAAA,eAAe,CAACW,OAAhB,CAAwBK,KAAxB;AACAhB,MAAAA,eAAe,CAACW,OAAhB,GAA0B,IAA1B;AACD,KAHO,EAGLO,OAHK,CAAR;AAIF,GALD,CApD0C,CA2D1C;;;AACA,QAAMC,2BAA2B,GAAG,UAACrB,KAAD,EAAQoB,OAAR,EAAkC;AAAA,QAAjBnB,OAAiB,uEAAP,EAAO;AACpE;AACA;AACA,QAAII,YAAY,CAACC,UAAb,KAA4B,SAAhC,EAA2C,OAHyB,CAKpE;AACA;;AACA,UAAMgB,SAAS,GAAG;AAChBC,MAAAA,KAAK,EAAE,sDADS;AAEhBC,MAAAA,IAAI,EAAE,sDAFU;AAGhB,SAAGvB;AAHa,KAAlB,CAPoE,CAapE;;AACA,QAAI,CAACC,eAAe,CAACW,OAArB,EAA8B;AAC5B;AACAM,MAAAA,oBAAoB,CAACC,OAAD,CAApB,CAF4B,CAI5B;AACA;;AACAlB,MAAAA,eAAe,CAACW,OAAhB,GAA0B,IAAIR,YAAJ,CAAiBL,KAAjB,EAAwBsB,SAAxB,CAA1B,CAN4B,CAQ5B;;AACAV,MAAAA,yBAAyB;AAC1B;AACF,GAzBD;;AA2BA,SAAO;AAAES,IAAAA;AAAF,GAAP;AAED,CAzFD;;GAAMtB,e;;AA2FN,eAAeA,eAAf","sourcesContent":["import React, { useRef } from \"react\";\r\nimport throttle from \"./useThrottle\"\r\n\r\nconst useNotification = (title, options) => {\r\n\r\n  const notificationRef = useRef();\r\n  const timerRef = useRef();\r\n\r\n  if (!(\"Notification\" in window)) {\r\n    return;\r\n  }\r\n// const fireNotif = () => {\r\n  if (Notification.permission !== \"granted\") {\r\n    try {\r\n      Notification.requestPermission().then((permission) => {\r\n        if (permission !== 'granted') return;\r\n        //else new Notification(title, options);\r\n      });\r\n    } catch (error) {\r\n      if (error instanceof TypeError) {\r\n        Notification.requestPermission((permission) => {\r\n          if (permission !== 'granted') return;\r\n          //else new Notification(title, options);\r\n        });\r\n      } else {\r\n        console.error(error);\r\n      }\r\n    }\r\n  }\r\n  // else {\r\n  //   new Notification(title, options);\r\n  // }\r\n// };\r\n\r\n  const setNotificationClickEvent = () => {\r\n    notificationRef.current.onclick = (event) => {\r\n      event.preventDefault();\r\n      window.focus();\r\n      notificationRef.current.close();\r\n    };\r\n  };\r\n\r\n  // Notification을 위한 타이머를 설정하는 함수!\r\n  // const setNotificationTimer = (timeout) => {\r\n  //   // clearTimeout을 하기 위해 timerRef에 저장해준다.\r\n  //   timerRef.current = setTimeout(() => {\r\n  //     // timeout에 넣어준 시간만큼 흐르면, 콜백이 실행되면서 timerRef.current에 null이 담기게 된다.\r\n  //     timerRef.current = null;\r\n  //\r\n  //     // 시간이 다 흘렀으면 푸시 알림이 꺼지도록 해준다.\r\n  //     notificationRef.current.close();\r\n  //     // 그리고 역할을 다한 notificationRef를 null로 초기화해준다.\r\n  //     notificationRef.current = null;\r\n  //   }, timeout);\r\n  // };\r\n  const setNotificationTimer = (timeout) => {\r\n     throttle(() => {\r\n       notificationRef.current.close();\r\n       notificationRef.current = null;\r\n     }, timeout);\r\n  };\r\n\r\n  // 어떤 알림을 보낼 것인지, 몇 초마다 알림을 보낼 것인지에 대한 함수\r\n  const fireNotificationWithTimeout = (title, timeout, options = {}) => {\r\n    // 만약 유저가 푸시 알림을 꺼놓았다면 함수가 실행되지 않게 미리 return을 해준다.\r\n    // 그런데 가드를 세워놨음에도 불구하고, Safari에서 실행되지 않는 문제점이 있었다. 이 문제는 해결중이다 ㅜㅜ!\r\n    if (Notification.permission !== 'granted') return;\r\n\r\n    // Notification API는 두 번째 인자로 option 값을 받는데, 뱃지 이미지와 아이콘 등을 설정해 줄 수 있다.\r\n    // 초기 badge, icon을 설정해주었다.\r\n    const newOption = {\r\n      badge: 'https://babble.gg/img/logos/babble-speech-bubble.png',\r\n      icon: 'https://babble.gg/img/logos/babble-speech-bubble.png',\r\n      ...options,\r\n    };\r\n\r\n    // 만약 notificationRef가 아직 초기화되지 않았다면, 타이머가 아직 동작하고 있는거니까 notificationRef가 없을 때에만 새로운 알림을 만든다.\r\n    if (!notificationRef.current) {\r\n      // 여기 들어왔다는건 타이머가 실행되지 않고 있다는 것이니까, 타이머를 만들어준다.\r\n      setNotificationTimer(timeout);\r\n\r\n      // 푸시 알림에서 보여줄 title과 위에서 우리가 만든 custom option을 넣어준다.\r\n      // 이 Notification 함수는 할당해도 바로 실행되기 때문에 첫 이벤트는 무조건 실행되고, 그 이후부터 타이머가 작동한다.\r\n      notificationRef.current = new Notification(title, newOption);\r\n\r\n      // // Notification의 Click Event를 새로 붙여준다.\r\n      setNotificationClickEvent();\r\n    }\r\n  };\r\n\r\n  return { fireNotificationWithTimeout };\r\n\r\n};\r\n\r\nexport default useNotification;\r\n"]},"metadata":{},"sourceType":"module"}